{
    "docs": [
        {
            "location": "/", 
            "text": "EggAnalysis2\n\n\nLibrary for analyzing EEG and ECoG data. Work in progress, not to be used/trusted yet.\n\n\n\n\nInstallation\n\n\nPkg\n.\nclone\n(\n)\n\n\n\n\n\n\n\n\nGeneral Functionality\n\n\n\n\nCreate a session with desired name and directory\n\n\nUse load_eeg function to load data into the session from specific channels\n\n\nUse lowpass_session or highpass_session to filter the session\n\n\nCreate plot using the appropriate plotting function\n\n\n\n\n\n\nIndex\n\n\n\n\nEggAnalysis2.AnalogData\n\n\nEggAnalysis2.DigitalData\n\n\nEggAnalysis2.Session\n\n\nEggAnalysis2.Spectrogram\n\n\nEggAnalysis2.ad_equals\n\n\nEggAnalysis2.dd_equals\n\n\nEggAnalysis2.debounce_discrete_signal\n\n\nEggAnalysis2.debounce_discrete_signal\n\n\nEggAnalysis2.down_sample\n\n\nEggAnalysis2.down_sample\n\n\nEggAnalysis2.format_full_array\n\n\nEggAnalysis2.highpass\n\n\nEggAnalysis2.highpass\n\n\nEggAnalysis2.highpass_session\n\n\nEggAnalysis2.ica\n\n\nEggAnalysis2.load_continuous\n\n\nEggAnalysis2.load_continuous_channels\n\n\nEggAnalysis2.load_eeg\n\n\nEggAnalysis2.lowpass\n\n\nEggAnalysis2.lowpass\n\n\nEggAnalysis2.lowpass_session\n\n\nEggAnalysis2.normalize_data\n\n\nEggAnalysis2.normalize_data\n\n\nEggAnalysis2.session_equals\n\n\nEggAnalysis2.threshold_01\n\n\nEggAnalysis2.threshold_01\n\n\nEggAnalysis2.toDecibels\n\n\nEggAnalysis2.toDecibels\n\n\nEggAnalysis2.truncate_by_index\n\n\nEggAnalysis2.truncate_by_index\n\n\nEggAnalysis2.truncate_by_value\n\n\nEggAnalysis2.truncate_by_value\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nEggAnalysis2.ad_equals\n \n \nMethod\n.\n\n\nad_equals(adone::AnaloglData, adtwo::AnalogData)\n\n\n\n\n\nCheck whether two analogdata objects are equal.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.dd_equals\n \n \nMethod\n.\n\n\ndd_equals(ddone::DigitalData, ddtwo::DigitalData)\n\n\n\n\n\nCheck whether two digitaldata objects are equal.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.debounce_discrete_signal\n \n \nMethod\n.\n\n\ndebounce_discrete_signal(x, min_samples_per_chunk)\n\n\n\n\n\nFor use after threshold_01. Remove any bounces shorter than min_samples_per_chunk, with the exception of a short leading bounce at the beginning of the array.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.debounce_discrete_signal\n \n \nMethod\n.\n\n\ndebounce_discrete_signal(dd::DigitalData, min_samples_per_chunk::Int64)\n\n\n\n\n\nFor use after threshold_01. Remove any bounces shorter than min_samples_per_chunk in every channel of x_all of the DigitalData object, with the exception of a short leading bounce at the beginning of the array.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.down_sample\n \n \nMethod\n.\n\n\ndown_sample(x::Vector{Float64}, factor::Int64)\n\n\n\n\n\nDownsample a vector x by a given factor. (If factor is 3, keep one value out of every three)\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.down_sample\n \n \nMethod\n.\n\n\ndown_sample(ad::AnalogData, factor::Int64)\n\n\n\n\n\nDownsample every channel in x_all of an analogdata object by a given factor.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.highpass\n \n \nFunction\n.\n\n\nhighpass(ad::AnalogData, cutoff, fs, order=5)\n\n\n\n\n\nHighpass filter every channel in x_all of an AnalogData object.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.highpass\n \n \nFunction\n.\n\n\nhighpass(data, cutoff, fs, order=5)\n\n\n\n\n\nHighpass filter data\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.lowpass\n \n \nFunction\n.\n\n\nlowpass(ad::AnalogData, cutoff, fs, order=5)\n\n\n\n\n\nLowpass filter every channel in x_all of an AnalogData object.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.lowpass\n \n \nFunction\n.\n\n\nlowpass(data, cutoff, fs, order=5)\n\n\n\n\n\nLowpass filter data\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.normalize_data\n \n \nMethod\n.\n\n\nnormalize_data(x)\n\n\n\n\n\nNormalize data\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.normalize_data\n \n \nMethod\n.\n\n\nnormalize_data(ad::AnalogData)\n\n\n\n\n\nNormalize every channel of x_all of an AnalogData object.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.threshold_01\n \n \nMethod\n.\n\n\nthreshold_01(x, threshold)\n\n\n\n\n\nTurn all values above a threshold into ones and all values below into zeros\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.threshold_01\n \n \nMethod\n.\n\n\nthreshold_01(ad::AnalogData, threshold)\n\n\n\n\n\nTurn all values above a threshold into ones and all values below into zeros for each channel in x_all of an AnalogData object.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.toDecibels\n \n \nMethod\n.\n\n\ntoDecibels(x, x_ref)\n\n\n\n\n\nCovert x to decibels with reference x_ref.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.toDecibels\n \n \nMethod\n.\n\n\ntoDecibels(ad::AnalogData, x_ref)\n\n\n\n\n\nCovert each channel of x_all of the AnalogData object to decibels with reference x_ref.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.truncate_by_index\n \n \nMethod\n.\n\n\ntruncate_by_index(x::Vector{}, t::Vector{}, index_range::Vector{})\n\n\n\n\n\nReturn copies of x and t truncated to the given range of samples. index_range is a list containing the start index (inclusive)and end index (exclusive). If index_range contains floats, they will be rounded down to ints. t must be a 1d array with the same length as dimension dim of x.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.truncate_by_index\n \n \nMethod\n.\n\n\ntruncate_by_index(analogdata::AnalogData, index_range::Vector{})\n\n\n\n\n\nTruncate t and every channel of x_all in the AnalogData object to the given range of sample.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.truncate_by_value\n \n \nMethod\n.\n\n\ntruncate_by_value(x::Vector{}, t::Vector{}, t_range::Vector{})\n\n\n\n\n\nReturn copies of x and t truncated to approximately the given time range. t_range is a list containing the start and end times in seconds. t must be a 1d array with the same length as dimension dim of x.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.truncate_by_value\n \n \nMethod\n.\n\n\ntruncate_by_value(analogdata::AnalogData, t_range::Vector{})\n\n\n\n\n\nTruncate t and every channel of x_all in the AnalogData object to approximately the given time range.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.AnalogData\n \n \nMethod\n.\n\n\nAnalogData\n(\nx_all\n::\nArray\n{\nFloat64,2\n}\n,\n \nt\n::\nVector\n{\nFloat64\n}\n;\n\n\noriginal_fs\n::\nInt64\n=\n30000\n,\n \nchannel_nums\n::\nVector\n{\nInt64\n}\n=\n[\n0\n,\n0\n]\n)\n\n\n\n\n\n\nCreate analogdata object given only data and time- assumes all channels are desired.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.DigitalData\n \n \nMethod\n.\n\n\nDigitalData\n(\nx_all\n::\nArray\n{\nBool,2\n}\n,\n \nt\n::\nVector\n{\nFloat64\n}\n;\n\n\noriginal_fs\n::\nInt64\n=\n30000\n,\n \nchannel_nums\n::\nVector\n{\nInt64\n}\n=\n[\n0\n,\n0\n]\n)\n\n\n\n\n\n\nCreate digitaldata object given only data and time- assumes all channels are desired.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.Spectrogram\n \n \nType\n.\n\n\nSpectrogram(analog_data::AnalogData, n=1024)\n\n\n\n\n\nCreate a Spectrogram object from an AnalogData object. N decides the size of time bins\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.format_full_array\n \n \nMethod\n.\n\n\nformat_full_array(x::Array{Float64, 1})\n\n\n\n\n\nReturn string will full-precision respresentation of floats in the array. For getting exact values in test cases.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.highpass_session\n \n \nFunction\n.\n\n\nhighpass_session\n(\nsession\n::\nSession\n,\n \nhighpass_cutoff\n::\nFloat64\n,\n \nhighpass_order\n::\nInt64\n=\n5\n,\n\n\nprefix\n::\nString\n=\n100_CH\n;\n \nn\n::\nInt64\n=\n256\n)\n\n\n\n\n\n\nHighpass filter the eeg_data of a session and return the new filtered session. Change n here if you want a different value for the spectrogram of the filtered data.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.ica\n \n \nMethod\n.\n\n\nica(ad::AnalogData)\n\n\n\n\n\nPerform ICA over x_all of an AnalogData object and return the updated AnalogData. Number of components assumed to be number of channels.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.load_continuous\n \n \nMethod\n.\n\n\nload_continuous(path::String, fs::Int64)\n\n\n\n\n\nReturn an array of the data and an array of the time values given a file path and sampling rate\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.load_continuous_channels\n \n \nFunction\n.\n\n\nload_continuous_channels(prefix::String, data_directory::String,fs::Int64,\nchannel_nums::Vector{Int64}, recording_num::Int64=1)\n\n\n\n\n\nCreates an analogdata object given the desired channel numbers, data directory, and data prefix. Recording num is to account for if there are multiple recordings, in which case the appropriate number is added to the filename.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.load_eeg\n \n \nFunction\n.\n\n\nload_eeg(session::Session, channel_nums::Vector{Int64})\n\n\n\n\n\nLoad EEG data into a session\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.lowpass_session\n \n \nFunction\n.\n\n\nlowpass_session(session::Session, lowpass_cutoff::Float64, lowpass_fs::Int64,\ndown_sample_factor::Int64, lowpass_order::Int64=5, prefix::String=\n100_CH\n)\n\n\n\n\n\nFilter the eeg_data of a session with both lowpass and downsampling and return the new filtered session. If no downsampling factor is provided, it is assumed to be 1 and no downsampling occurs. Change n here if you want a different value for the spectrogram of the filtered data.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.session_equals\n \n \nMethod\n.\n\n\nfunction\n \nsession_equals\n(\ns1\n::\nSession\n,\n \ns2\n::\nSession\n)\n\n\n\n\n\n\nCheck whether two session objects are equal.\n\n\nsource\n\n\n#\n\n\nEggAnalysis2.Session\n \n \nType\n.\n\n\nSession(name::String, directory::String, eeg_data=Nullable{AnalogData}(), n::Int64=256))\n\n\n\n\n\nCreate a Session object. Providing eeg_data will automatically create a spectrogram, so change n here if necessary.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#egganalysis2", 
            "text": "Library for analyzing EEG and ECoG data. Work in progress, not to be used/trusted yet.", 
            "title": "EggAnalysis2"
        }, 
        {
            "location": "/#installation", 
            "text": "Pkg . clone ( )", 
            "title": "Installation"
        }, 
        {
            "location": "/#general-functionality", 
            "text": "Create a session with desired name and directory  Use load_eeg function to load data into the session from specific channels  Use lowpass_session or highpass_session to filter the session  Create plot using the appropriate plotting function", 
            "title": "General Functionality"
        }, 
        {
            "location": "/#index", 
            "text": "EggAnalysis2.AnalogData  EggAnalysis2.DigitalData  EggAnalysis2.Session  EggAnalysis2.Spectrogram  EggAnalysis2.ad_equals  EggAnalysis2.dd_equals  EggAnalysis2.debounce_discrete_signal  EggAnalysis2.debounce_discrete_signal  EggAnalysis2.down_sample  EggAnalysis2.down_sample  EggAnalysis2.format_full_array  EggAnalysis2.highpass  EggAnalysis2.highpass  EggAnalysis2.highpass_session  EggAnalysis2.ica  EggAnalysis2.load_continuous  EggAnalysis2.load_continuous_channels  EggAnalysis2.load_eeg  EggAnalysis2.lowpass  EggAnalysis2.lowpass  EggAnalysis2.lowpass_session  EggAnalysis2.normalize_data  EggAnalysis2.normalize_data  EggAnalysis2.session_equals  EggAnalysis2.threshold_01  EggAnalysis2.threshold_01  EggAnalysis2.toDecibels  EggAnalysis2.toDecibels  EggAnalysis2.truncate_by_index  EggAnalysis2.truncate_by_index  EggAnalysis2.truncate_by_value  EggAnalysis2.truncate_by_value", 
            "title": "Index"
        }, 
        {
            "location": "/#functions", 
            "text": "#  EggAnalysis2.ad_equals     Method .  ad_equals(adone::AnaloglData, adtwo::AnalogData)  Check whether two analogdata objects are equal.  source  #  EggAnalysis2.dd_equals     Method .  dd_equals(ddone::DigitalData, ddtwo::DigitalData)  Check whether two digitaldata objects are equal.  source  #  EggAnalysis2.debounce_discrete_signal     Method .  debounce_discrete_signal(x, min_samples_per_chunk)  For use after threshold_01. Remove any bounces shorter than min_samples_per_chunk, with the exception of a short leading bounce at the beginning of the array.  source  #  EggAnalysis2.debounce_discrete_signal     Method .  debounce_discrete_signal(dd::DigitalData, min_samples_per_chunk::Int64)  For use after threshold_01. Remove any bounces shorter than min_samples_per_chunk in every channel of x_all of the DigitalData object, with the exception of a short leading bounce at the beginning of the array.  source  #  EggAnalysis2.down_sample     Method .  down_sample(x::Vector{Float64}, factor::Int64)  Downsample a vector x by a given factor. (If factor is 3, keep one value out of every three)  source  #  EggAnalysis2.down_sample     Method .  down_sample(ad::AnalogData, factor::Int64)  Downsample every channel in x_all of an analogdata object by a given factor.  source  #  EggAnalysis2.highpass     Function .  highpass(ad::AnalogData, cutoff, fs, order=5)  Highpass filter every channel in x_all of an AnalogData object.  source  #  EggAnalysis2.highpass     Function .  highpass(data, cutoff, fs, order=5)  Highpass filter data  source  #  EggAnalysis2.lowpass     Function .  lowpass(ad::AnalogData, cutoff, fs, order=5)  Lowpass filter every channel in x_all of an AnalogData object.  source  #  EggAnalysis2.lowpass     Function .  lowpass(data, cutoff, fs, order=5)  Lowpass filter data  source  #  EggAnalysis2.normalize_data     Method .  normalize_data(x)  Normalize data  source  #  EggAnalysis2.normalize_data     Method .  normalize_data(ad::AnalogData)  Normalize every channel of x_all of an AnalogData object.  source  #  EggAnalysis2.threshold_01     Method .  threshold_01(x, threshold)  Turn all values above a threshold into ones and all values below into zeros  source  #  EggAnalysis2.threshold_01     Method .  threshold_01(ad::AnalogData, threshold)  Turn all values above a threshold into ones and all values below into zeros for each channel in x_all of an AnalogData object.  source  #  EggAnalysis2.toDecibels     Method .  toDecibels(x, x_ref)  Covert x to decibels with reference x_ref.  source  #  EggAnalysis2.toDecibels     Method .  toDecibels(ad::AnalogData, x_ref)  Covert each channel of x_all of the AnalogData object to decibels with reference x_ref.  source  #  EggAnalysis2.truncate_by_index     Method .  truncate_by_index(x::Vector{}, t::Vector{}, index_range::Vector{})  Return copies of x and t truncated to the given range of samples. index_range is a list containing the start index (inclusive)and end index (exclusive). If index_range contains floats, they will be rounded down to ints. t must be a 1d array with the same length as dimension dim of x.  source  #  EggAnalysis2.truncate_by_index     Method .  truncate_by_index(analogdata::AnalogData, index_range::Vector{})  Truncate t and every channel of x_all in the AnalogData object to the given range of sample.  source  #  EggAnalysis2.truncate_by_value     Method .  truncate_by_value(x::Vector{}, t::Vector{}, t_range::Vector{})  Return copies of x and t truncated to approximately the given time range. t_range is a list containing the start and end times in seconds. t must be a 1d array with the same length as dimension dim of x.  source  #  EggAnalysis2.truncate_by_value     Method .  truncate_by_value(analogdata::AnalogData, t_range::Vector{})  Truncate t and every channel of x_all in the AnalogData object to approximately the given time range.  source  #  EggAnalysis2.AnalogData     Method .  AnalogData ( x_all :: Array { Float64,2 } ,   t :: Vector { Float64 } ;  original_fs :: Int64 = 30000 ,   channel_nums :: Vector { Int64 } = [ 0 , 0 ] )   Create analogdata object given only data and time- assumes all channels are desired.  source  #  EggAnalysis2.DigitalData     Method .  DigitalData ( x_all :: Array { Bool,2 } ,   t :: Vector { Float64 } ;  original_fs :: Int64 = 30000 ,   channel_nums :: Vector { Int64 } = [ 0 , 0 ] )   Create digitaldata object given only data and time- assumes all channels are desired.  source  #  EggAnalysis2.Spectrogram     Type .  Spectrogram(analog_data::AnalogData, n=1024)  Create a Spectrogram object from an AnalogData object. N decides the size of time bins  source  #  EggAnalysis2.format_full_array     Method .  format_full_array(x::Array{Float64, 1})  Return string will full-precision respresentation of floats in the array. For getting exact values in test cases.  source  #  EggAnalysis2.highpass_session     Function .  highpass_session ( session :: Session ,   highpass_cutoff :: Float64 ,   highpass_order :: Int64 = 5 ,  prefix :: String = 100_CH ;   n :: Int64 = 256 )   Highpass filter the eeg_data of a session and return the new filtered session. Change n here if you want a different value for the spectrogram of the filtered data.  source  #  EggAnalysis2.ica     Method .  ica(ad::AnalogData)  Perform ICA over x_all of an AnalogData object and return the updated AnalogData. Number of components assumed to be number of channels.  source  #  EggAnalysis2.load_continuous     Method .  load_continuous(path::String, fs::Int64)  Return an array of the data and an array of the time values given a file path and sampling rate  source  #  EggAnalysis2.load_continuous_channels     Function .  load_continuous_channels(prefix::String, data_directory::String,fs::Int64,\nchannel_nums::Vector{Int64}, recording_num::Int64=1)  Creates an analogdata object given the desired channel numbers, data directory, and data prefix. Recording num is to account for if there are multiple recordings, in which case the appropriate number is added to the filename.  source  #  EggAnalysis2.load_eeg     Function .  load_eeg(session::Session, channel_nums::Vector{Int64})  Load EEG data into a session  source  #  EggAnalysis2.lowpass_session     Function .  lowpass_session(session::Session, lowpass_cutoff::Float64, lowpass_fs::Int64,\ndown_sample_factor::Int64, lowpass_order::Int64=5, prefix::String= 100_CH )  Filter the eeg_data of a session with both lowpass and downsampling and return the new filtered session. If no downsampling factor is provided, it is assumed to be 1 and no downsampling occurs. Change n here if you want a different value for the spectrogram of the filtered data.  source  #  EggAnalysis2.session_equals     Method .  function   session_equals ( s1 :: Session ,   s2 :: Session )   Check whether two session objects are equal.  source  #  EggAnalysis2.Session     Type .  Session(name::String, directory::String, eeg_data=Nullable{AnalogData}(), n::Int64=256))  Create a Session object. Providing eeg_data will automatically create a spectrogram, so change n here if necessary.  source", 
            "title": "Functions"
        }
    ]
}